<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Maze Solver</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Condensed';
            font-weight: 400;
            background-color: #000;
            color: #fff;
            overflow: hidden;
        }
        canvas {
            background-color: #000022;
            border: 2px solid #555;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: #000;
            font-weight: 700;
            transition-property: all;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 300ms;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .btn-bfs {
            background-color: #22d3ee; 
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.5);
        }
        .btn-bfs:hover {
            background-color: #67e8f9;
        }
        .btn-dfs {
            background-color: #fb923c;
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.5);
        }
        .btn-dfs:hover {
            background-color: #fdba74;
        }
        .btn-reset {
            background-color: #ef4444;
            color: #fff;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }
        .btn-reset:hover {
            background-color: #f87171;
        }
        .btn:disabled {
            background-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl md:text-4xl text-yellow-400 mb-4 text-center" style="text-shadow: 2px 2px #f00;">Pac-Man Pathfind</h1>

    <canvas id="gameCanvas" class="rounded-lg"></canvas>
    <div class="flex flex-wrap gap-4 my-6 justify-center">
        <button id="bfsButton" class="btn btn-bfs">Start BFS</button>
        <button id="dfsButton" class="btn btn-dfs">Start DFS</button>
        <button id="resetButton" class="btn btn-reset">Reset</button>
    </div>

    <div id="status" class="h-6 text-lg text-yellow-400 text-center">Select an Algorithm! (Click on the canvas to set a new Goal.)</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const statusEl = document.getElementById('status');

            const bfsButton = document.getElementById('bfsButton');
            const dfsButton = document.getElementById('dfsButton');
            const resetButton = document.getElementById('resetButton');

            const COLS = 21;
            const ROWS = 21;
            const CELL_SIZE = Math.floor(Math.min(window.innerWidth * 0.8, window.innerHeight * 0.6) / COLS);

            canvas.width = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;

            const WALL_COLOR = '#0000FF'; // Blue
            const PATH_COLOR = '#000022'; // Dark Blue/Black
            const PLAYER_COLOR = '#FFFF00'; // Yellow
            const GOAL_COLOR = '#FFFFFF'; // White
            const VISITED_COLOR = 'rgba(0, 191, 255, 0.3)'; // Sky Blue
            const FINAL_PATH_COLOR = '#FFFF00'; // Yellow

            // Maze Layout: 1 for Wall, 0 for Path
            const maze = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];

            let startPos, goalPos;
            let animationInterval;

            function drawMaze() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const cellType = maze[y][x];
                        ctx.fillStyle = (cellType === 1) ? WALL_COLOR : PATH_COLOR;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

                        if (cellType === 2) {
                            startPos = { x, y };
                            drawPlayer(x, y);
                        } else if (cellType === 3) {
                            goalPos = { x, y };
                            drawGoal(x, y);
                        }
                    }
                }
            }

            function drawPlayer(x, y) {
                const radius = CELL_SIZE * 0.35;
                const centerX = x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = y * CELL_SIZE + CELL_SIZE / 2;
                ctx.fillStyle = PLAYER_COLOR;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0.2 * Math.PI, 1.8 * Math.PI, false);
                ctx.lineTo(centerX, centerY);
                ctx.fill();
            }

            function drawGoal(x, y) {
                const radius = CELL_SIZE * 0.2;
                const centerX = x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = y * CELL_SIZE + CELL_SIZE / 2;
                ctx.fillStyle = GOAL_COLOR;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawCell(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }

            function drawPath(path) {
                ctx.fillStyle = FINAL_PATH_COLOR;
                const radius = CELL_SIZE * 0.1;
                for (let i = 1; i < path.length - 1; i++) { 
                    const node = path[i];
                    const centerX = node.x * CELL_SIZE + CELL_SIZE / 2;
                    const centerY = node.y * CELL_SIZE + CELL_SIZE / 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            function getNeighbors(x, y) {
                const neighbors = [];
                // [dx, dy]
                const directions = [ [0, -1], [1, 0], [0, 1], [-1, 0] ]; // Up, Right, Down, Left

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    // Check boundaries and if it's not a wall
                    if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && maze[newY][newX] !== 1) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
                return neighbors;
            }

            function solve(method) {
                const queue = []; // Queue for BFS
                const stack = []; // Stack for DFS
                
                const startNode = startPos;
                const endNode = goalPos;

                const visited = new Set();
                const parent = new Map();
                const visitedOrder = [];

                const startKey = `${startNode.x},${startNode.y}`;
                visited.add(startKey);

                if (method === 'bfs') {
                    queue.push(startNode);
                } else { // dfs
                    stack.push(startNode);
                }

                let pathFound = false;

                while (queue.length > 0 || stack.length > 0) {
                    let currentNode;

                    if (method === 'bfs') {
                        currentNode = queue.shift();
                    } else {
                        currentNode = stack.pop();
                    }

                    // Don't animate start/end nodes
                    if (currentNode.x !== startNode.x || currentNode.y !== startNode.y) {
                        visitedOrder.push(currentNode);
                    }

                    // Check for goal
                    if (currentNode.x === endNode.x && currentNode.y === endNode.y) {
                        pathFound = true;
                        break;
                    }

                    const neighbors = getNeighbors(currentNode.x, currentNode.y);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            parent.set(neighborKey, currentNode);
                            if (method === 'bfs') {
                                queue.push(neighbor);
                            } else {
                                stack.push(neighbor);
                            }
                        }
                    }
                }

                // Reconstruct path
                const path = [];
                if (pathFound) {
                    let current = endNode;
                    while (current.x !== startNode.x || current.y !== startNode.y) {
                        path.unshift(current);
                        const currentKey = `${current.x},${current.y}`;
                        current = parent.get(currentKey);
                    }
                    path.unshift(startNode);
                }
                
                return { visitedOrder, path, pathFound };
            }

            function animateSearch(visitedOrder, path, pathFound) {
                let i = 0;
                const animationSpeed = 25; // ms per step
                
                animationInterval = setInterval(() => {
                    if (i >= visitedOrder.length) {
                        clearInterval(animationInterval);
                        if (pathFound) {
                            drawPath(path);
                            statusEl.textContent = "Path Found!";
                        } else {
                            statusEl.textContent = "No Path Found!";
                        }
                        resetButton.disabled = false;
                        return;
                    }

                    const node = visitedOrder[i];
                    // Don't redraw over goal
                    if (node.x !== goalPos.x || node.y !== goalPos.y) {
                        drawCell(node.x, node.y, VISITED_COLOR);
                    }
                    i++;
                }, animationSpeed);
            }
            
            function startSearch(method) {
                resetGame();
                
                bfsButton.disabled = true;
                dfsButton.disabled = true;
                resetButton.disabled = true;

                statusEl.textContent = `Solving with ${method.toUpperCase()}...`;

                setTimeout(() => {
                    const { visitedOrder, path, pathFound } = solve(method);
                    animateSearch(visitedOrder, path, pathFound);
                }, 100);
            }

            function resetGame() {
                clearInterval(animationInterval);
                drawMaze();
                statusEl.textContent = "Select an Algorithm! (Click on the canvas to set a new Goal.)";
                bfsButton.disabled = false;
                dfsButton.disabled = false;
                resetButton.disabled = false;
            }

            bfsButton.addEventListener('click', () => startSearch('bfs'));
            dfsButton.addEventListener('click', () => startSearch('dfs'));
            resetButton.addEventListener('click', resetGame);

            canvas.addEventListener('click', (event) => {
                // Don't allow changing goal while an algorithm is running
                if (bfsButton.disabled) {
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const mouseX = (event.clientX - rect.left) * scaleX;
                const mouseY = (event.clientY - rect.top) * scaleY;

                const gridX = Math.floor(mouseX / CELL_SIZE);
                const gridY = Math.floor(mouseY / CELL_SIZE);

                if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS &&
                    maze[gridY][gridX] !== 1 &&
                    (gridX !== startPos.x || gridY !== startPos.y)
                ) {
                    maze[goalPos.y][goalPos.x] = 0; 
                    maze[gridY][gridX] = 3;
                    // goalPos will be updated by drawMaze() in resetGame()
                    // Redraw everything
                    resetGame();
                    statusEl.textContent = "New goal set! Select algorithm.";
                }
            });

            drawMaze();
        });
    </script>
</body>
</html>
